package exploit

import (
	"bufio"
	_ "embed"
	"encoding/base64"
	"errors"
	"os"
	"strings"
	"sync"
	"sync/atomic"

	jwtlib "github.com/golang-jwt/jwt/v5"
)

//go:embed data/jwt-secrets.txt
var embeddedSecretsData string //nolint:gosec

var (
	weakSecretsOnce sync.Once
	weakSecretsList []string //nolint:gosec
)

// WeakSecrets returns the built-in list of JWT secrets embedded from the
// danielmiessler/SecLists scraped-JWT-secrets wordlist. The list is parsed
// once and cached for subsequent calls.
//
//nolint:gosec
func WeakSecrets() []string {
	weakSecretsOnce.Do(func() {
		scanner := bufio.NewScanner(strings.NewReader(embeddedSecretsData))
		for scanner.Scan() {
			weakSecretsList = append(weakSecretsList, scanner.Text())
		}
	})
	return weakSecretsList
}

// CrackResult holds the outcome of a secret crack attempt.
type CrackResult struct {
	Found  bool
	Secret string //nolint:gosec
}

// CrackSecret tests each candidate secret against the token's HMAC signature
// and returns the first match. Candidates are tried concurrently using a
// worker pool (workers goroutines). Pass workers â‰¤ 0 to use one goroutine per
// candidate (unbounded).
//
// Returns (CrackResult{Found: false}, nil) when no candidate matches.
// Returns a non-nil error only for structural problems: malformed token or
// non-HMAC algorithm.
func CrackSecret(tokenString string, candidates []string, workers int) (CrackResult, error) { //nolint:gosec
	parts := strings.SplitN(tokenString, ".", 3)
	if len(parts) != 3 {
		return CrackResult{}, errors.New("invalid JWT: expected 3 dot-separated parts")
	}

	token, _, err := new(jwtlib.Parser).ParseUnverified(tokenString, jwtlib.MapClaims{})
	if err != nil && !errors.Is(err, jwtlib.ErrTokenUnverifiable) && !errors.Is(err, jwtlib.ErrTokenSignatureInvalid) {
		return CrackResult{}, err
	}
	if token == nil {
		return CrackResult{}, errors.New("invalid JWT token")
	}

	hmacMethod, ok := token.Method.(*jwtlib.SigningMethodHMAC)
	if !ok {
		return CrackResult{}, errors.New("token does not use an HMAC algorithm; cracking is only supported for HS256, HS384, and HS512")
	}

	signingInput := parts[0] + "." + parts[1]
	originalSig, err := base64.RawURLEncoding.DecodeString(parts[2])
	if err != nil {
		return CrackResult{}, errors.New("invalid JWT: cannot decode signature")
	}

	if len(candidates) == 0 {
		return CrackResult{Found: false}, nil
	}

	jobs := make(chan string, len(candidates))
	for _, c := range candidates {
		jobs <- c
	}
	close(jobs)

	var (
		once        sync.Once
		mu          sync.Mutex
		foundSecret string
		didFind     atomic.Bool
	)
	var wg sync.WaitGroup

	if workers <= 0 {
		workers = len(candidates)
	}

	for i := 0; i < workers; i++ {
		wg.Add(1)
		go func() {
			defer wg.Done()
			for candidate := range jobs {
				if didFind.Load() {
					return
				}
				if hmacMethod.Verify(signingInput, originalSig, []byte(candidate)) == nil {
					once.Do(func() {
						mu.Lock()
						foundSecret = candidate
						mu.Unlock()
						didFind.Store(true)
					})
					return
				}
			}
		}()
	}

	wg.Wait()

	if didFind.Load() {
		mu.Lock()
		secret := foundSecret
		mu.Unlock()
		return CrackResult{Found: true, Secret: secret}, nil
	}
	return CrackResult{Found: false}, nil
}

// SecretsFromFile reads candidate secrets from a file, one per line.
// Blank lines are skipped.
func SecretsFromFile(path string) ([]string, error) {
	f, err := os.Open(path) //nolint:gosec
	if err != nil {
		return nil, err
	}
	defer f.Close()

	var secrets []string
	scanner := bufio.NewScanner(f)
	for scanner.Scan() {
		line := scanner.Text()
		secrets = append(secrets, line)
	}
	return secrets, scanner.Err()
}
