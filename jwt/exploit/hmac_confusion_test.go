package exploit_test

import (
	"crypto/x509"
	"encoding/pem"
	"testing"

	"github.com/cerberauth/jwtop/jwt/exploit"
	jwtlib "github.com/golang-jwt/jwt/v5"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

func TestHMACConfusion_RS256TokenBecomesHS256(t *testing.T) {
	token, key := makeRS256Token(t)
	pubPEM := rsaPublicKeyPEM(t, key)

	result, err := exploit.HMACConfusion(token, pubPEM)
	require.NoError(t, err)
	assert.Equal(t, "HS256", tokenAlg(t, result))
}

func TestHMACConfusion_ResultVerifiesWithPublicKeyAsSecret(t *testing.T) {
	token, key := makeRS256Token(t)
	pubPEM := rsaPublicKeyPEM(t, key)

	result, err := exploit.HMACConfusion(token, pubPEM)
	require.NoError(t, err)

	parsed, err := jwtlib.Parse(result, func(tok *jwtlib.Token) (interface{}, error) {
		return pubPEM, nil
	})
	require.NoError(t, err)
	assert.True(t, parsed.Valid)
}

func TestHMACConfusion_ES256TokenBecomesHS256(t *testing.T) {
	token, key := makeES256Token(t)

	// Encode EC public key as PEM.
	der, err := x509.MarshalPKIXPublicKey(&key.PublicKey)
	require.NoError(t, err)
	pubPEM := pem.EncodeToMemory(&pem.Block{Type: "PUBLIC KEY", Bytes: der})

	result, err := exploit.HMACConfusion(token, pubPEM)
	require.NoError(t, err)
	assert.Equal(t, "HS256", tokenAlg(t, result))
}

func TestHMACConfusion_HMACTokenReturnsError(t *testing.T) {
	token := makeHS256Token(t, "secret")
	_, err := exploit.HMACConfusion(token, []byte("irrelevant"))
	assert.Error(t, err)
	assert.Contains(t, err.Error(), "HMAC confusion requires")
}

func TestHMACConfusion_MalformedTokenReturnsError(t *testing.T) {
	_, err := exploit.HMACConfusion("not-a-jwt", []byte("key"))
	assert.Error(t, err)
}
