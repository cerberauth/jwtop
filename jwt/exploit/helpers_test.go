package exploit_test

import (
	"crypto/ecdsa"
	"crypto/elliptic"
	"crypto/rand"
	"crypto/rsa"
	"crypto/x509"
	"encoding/base64"
	"encoding/json"
	"encoding/pem"
	"strings"
	"testing"

	jwtlib "github.com/golang-jwt/jwt/v5"
	"github.com/stretchr/testify/require"
)

func makeHS256Token(t *testing.T, secret string) string {
	t.Helper()
	tok := jwtlib.NewWithClaims(jwtlib.SigningMethodHS256, jwtlib.MapClaims{"sub": "user1", "role": "user"})
	s, err := tok.SignedString([]byte(secret))
	require.NoError(t, err)
	return s
}

func makeRS256Token(t *testing.T) (string, *rsa.PrivateKey) {
	t.Helper()
	key, err := rsa.GenerateKey(rand.Reader, 2048)
	require.NoError(t, err)
	tok := jwtlib.NewWithClaims(jwtlib.SigningMethodRS256, jwtlib.MapClaims{"sub": "user1"})
	s, err := tok.SignedString(key)
	require.NoError(t, err)
	return s, key
}

func makeES256Token(t *testing.T) (string, *ecdsa.PrivateKey) {
	t.Helper()
	key, err := ecdsa.GenerateKey(elliptic.P256(), rand.Reader)
	require.NoError(t, err)
	tok := jwtlib.NewWithClaims(jwtlib.SigningMethodES256, jwtlib.MapClaims{"sub": "user1"})
	s, err := tok.SignedString(key)
	require.NoError(t, err)
	return s, key
}

func rsaPublicKeyPEM(t *testing.T, key *rsa.PrivateKey) []byte {
	t.Helper()
	der, err := x509.MarshalPKIXPublicKey(&key.PublicKey)
	require.NoError(t, err)
	return pem.EncodeToMemory(&pem.Block{Type: "PUBLIC KEY", Bytes: der})
}

func tokenAlg(t *testing.T, tokenString string) string {
	t.Helper()
	parts := strings.SplitN(tokenString, ".", 3)
	require.Len(t, parts, 3, "expected 3-part JWT")
	headerJSON, err := base64.RawURLEncoding.DecodeString(parts[0])
	require.NoError(t, err, "decoding header")
	var header map[string]interface{}
	require.NoError(t, json.Unmarshal(headerJSON, &header))
	alg, _ := header["alg"].(string)
	return alg
}

func tokenParts(tokenString string) []string {
	return strings.SplitN(tokenString, ".", 3)
}
