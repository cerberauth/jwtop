package exploit_test

import (
	"testing"

	"github.com/cerberauth/jwtop/jwt/exploit"
	jwtlib "github.com/golang-jwt/jwt/v5"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

func TestKidInjection_SetsKidHeader(t *testing.T) {
	token := makeHS256Token(t, "secret")
	result, err := exploit.KidInjection(token, "injected-kid", nil, []byte("secret"))
	require.NoError(t, err)

	tok, _, err := new(jwtlib.Parser).ParseUnverified(result, jwtlib.MapClaims{})
	require.NoError(t, err)
	assert.Equal(t, "injected-kid", tok.Header["kid"])
}

func TestKidInjection_NilMethodUsesOriginalMethod(t *testing.T) {
	token := makeHS256Token(t, "secret")
	result, err := exploit.KidInjection(token, "kid-val", nil, []byte("secret"))
	require.NoError(t, err)
	assert.Equal(t, "HS256", tokenAlg(t, result))
}

func TestKidSQLInjection_UsesDefaultPayload(t *testing.T) {
	token := makeHS256Token(t, "secret")
	result, err := exploit.KidSQLInjection(token, exploit.DefaultKidSQLPayload, []byte("secret"))
	require.NoError(t, err)

	tok, _, err := new(jwtlib.Parser).ParseUnverified(result, jwtlib.MapClaims{})
	require.NoError(t, err)
	assert.Equal(t, exploit.DefaultKidSQLPayload, tok.Header["kid"])
}

func TestKidPathTraversal_UsesDefaultPayload(t *testing.T) {
	token := makeHS256Token(t, "secret")
	result, err := exploit.KidPathTraversal(token, exploit.DefaultKidPathTraversalPayload, []byte(""))
	require.NoError(t, err)

	tok, _, err := new(jwtlib.Parser).ParseUnverified(result, jwtlib.MapClaims{})
	require.NoError(t, err)
	assert.Equal(t, exploit.DefaultKidPathTraversalPayload, tok.Header["kid"])
}

func TestKidInjection_MalformedTokenReturnsError(t *testing.T) {
	_, err := exploit.KidInjection("not-a-jwt", "kid", nil, []byte("key"))
	assert.Error(t, err)
}
