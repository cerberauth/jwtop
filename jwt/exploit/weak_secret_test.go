package exploit_test

import (
	"testing"

	"github.com/cerberauth/jwtop/jwt/exploit"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

func TestCrackSecret_FoundInList(t *testing.T) {
	token := makeHS256Token(t, "hunter2")
	result, err := exploit.CrackSecret(token, []string{"wrong", "hunter2", "also-wrong"}, 4)
	require.NoError(t, err)
	assert.True(t, result.Found)
	assert.Equal(t, "hunter2", result.Secret)
}

func TestCrackSecret_BlankSecret(t *testing.T) {
	token := makeHS256Token(t, "")
	result, err := exploit.CrackSecret(token, []string{""}, 1)
	require.NoError(t, err)
	assert.True(t, result.Found)
	assert.Equal(t, "", result.Secret)
}

func TestCrackSecret_NotFound(t *testing.T) {
	token := makeHS256Token(t, "verylongrandomsecretthatisnotinanylist")
	result, err := exploit.CrackSecret(token, []string{"wrong", "also-wrong"}, 4)
	require.NoError(t, err)
	assert.False(t, result.Found)
	assert.Empty(t, result.Secret)
}

func TestCrackSecret_EmptyCandidates(t *testing.T) {
	token := makeHS256Token(t, "secret")
	result, err := exploit.CrackSecret(token, nil, 1)
	require.NoError(t, err)
	assert.False(t, result.Found)
}

func TestCrackSecret_WeakSecretsDictionary(t *testing.T) {
	token := makeHS256Token(t, "secret")
	result, err := exploit.CrackSecret(token, exploit.WeakSecrets(), 8)
	require.NoError(t, err)
	assert.True(t, result.Found)
	assert.Equal(t, "secret", result.Secret)
}

func TestCrackSecret_NonHMACAlgorithmReturnsError(t *testing.T) {
	noneToken := "eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJzdWIiOiIxMjM0NTY3ODkwIn0."
	_, err := exploit.CrackSecret(noneToken, []string{"secret"}, 1)
	assert.Error(t, err)
	assert.Contains(t, err.Error(), "HMAC")
}

func TestCrackSecret_MalformedTokenReturnsError(t *testing.T) {
	_, err := exploit.CrackSecret("not.a.valid.jwt.with.too.many.parts", []string{"x"}, 1)
	assert.Error(t, err)
}

func TestCrackSecret_InvalidJWTReturnsError(t *testing.T) {
	_, err := exploit.CrackSecret("notjwt", []string{"x"}, 1)
	assert.Error(t, err)
}
